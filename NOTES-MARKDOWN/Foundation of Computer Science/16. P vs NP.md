> [!warning] RECALL
> A decider for a language outputs YES if a string is IN the language.

> [!tldr] **TLDR**
> - P is the class of languages for which membership can be decided quickly. 
> - NP is the class of languages for which membership can be verified quickly.

## P

P is the set of [[11. Problems as Languages#Decision problems|DECISION PROBLEMS]] for which we have a decider that runs in polynomial time ($O(n^k)$) on a Deterministic [[9. Turing Machines|TM]], that is, THE [[12. Algorithms|ALGORITHM]] OUTPUTS A **YES OR NO ANSWER**.

![[Pasted image 20250830112645.png]]

> [!example]
> Given a graph and two nodes, “Is there a path of length ≤ k between them?” is in P if there is a polynomial-time algorithm to answer yes/no.

> [!example]
> **Language**:
> $$\large Lₛₒᵣₜ = \{ 〈x,y〉 ∣ y\text{ is a correct sorted version of }x \}$$
> **Decider**:
> A deterministic Turing machine (or algorithm) that, given $〈x,y〉$, accepts only when y is a permutation of x in nondecreasing order. 
> So it accepts if $〈x,y〉$ (with that condition) is part of the language basically.
> 


## NP

NP is the same thing, but the decider is non-deterministic.
This means that the decider can theoretically **simultaneously check all the possible paths** or branches (every branch uses at most polynomially many stages.), and accept in polynomial time.

![[Pasted image 20250830195138.png]]

> [!example]
> ![[Pasted image 20250831143339.png]]
> Here at each step the NFA could branch, and each branch that gets to a final state has polynomially many steps.
> 
> ![[Pasted image 20250831172302.png]]


### Verifier

A verifier is a deterministic turing machine that can tell whether a "guess" is a solution or not in polynomial time.

![[Pasted image 20250831181054.png]]

Where:
- $w$ is the input string
- $c$ is the certificate, which is basically the non-deterministic "guess" to verify.

> [!example] Usage example
> On input $⟨w, c⟩$, where $w$ and $c$ are strings: 
> Simulate $N$ on input $w$, treating each symbol of $c$ as a description of the nondeterministic choice to make at each step.

---

## Polynomial reducibility

![[Pasted image 20250901091845.png]]

![[Pasted image 20250901092106.png]]

Meaning that you can **map the input of A to an input of B** (using function $f$) and **B can still run its decider on it in polynomial time** (mapping + solving is still polynomial).

---

## NP completeness

![[Pasted image 20250901091321.png]]

![[Pasted image 20250901092420.png]]
