A theorem used to prove non-regularity of infinite languages.

Consider the language C = {$w | w$ has an equal number of 0s and 1s}, we want to prove that it's not regular.

> [!danger] Important
> For an automata, recognizing a language implies **accepting every string contained** in it, and **rejecting every string not contained** in it.


We take as example the string **0011** and we construct an automata that accepts it:

![](Pasted%20image%2020241121151608.png)

In this specific case, you can see that while it accepts **0011**, it also accepts **0111**, which is NOT in the language (because it has unequal amount of **0**'s and **1**'s).

> [!attention]
> This phenomenon can be summed up as the notion that **a DFA can't keep track of the history of it's states**, so in this specific case, it can't count the number of **1**'s and **0**'s, hence it's impossible to construct an automata that distinguishes the two strings mentioned.


**This scenario can be detected by using the pumping lemma**, which is explained below.

---

## Proof

If $A$ is a [[Regular Languages|regular language]], then there is a number $p$ (pumping length) where if $s$ is a string in $A$ of length at least $p$, then $s$ may be divided into three pieces, $s = xyz$, satisfying the following conditions:

1. for each $i ≥ 0$, $xy^iz ∈ A$
2. $|y| > 0$
3. $|xy| ≤ p$

The goal is to **find a string that doesn't respect these conditions**, to show that $A$ is not regular.

> [!hint]
> - $x$, $y$ and $z$ are substrings, not necessarily characters.
> - $|s|$ represents the length of string $s$.
> - $y^i$ means that $i$ copies of $y$ are concatenated together, and $y^0$ equals ε.

> [!warning]
> This theorem holds for every string in language $A$ that has length $\geq p$. 
> What if no strings in $A$ are of length at least $p$?
> Then the theorem is vacuously true, because the 3 conditions hold if there aren't any matching strings.
> **BUT IN AN INFINITE LANGUAGE, THERE ARE INFINITE STRINGS WITH INFINITE LENGTH**.


Assumptions:
- We have an hypothetical DFA $M$ that accepts $A$ (because we assume $A$ is regular therefore it must exist) and every string in it. We call its number of states $p$.
- $s$ is a string in $A$, with a length $n$, that is $\geq p$

Let's consider the states of $M$ that $s$ goes through.
It starts at the start state $q_1$ (before the string begins), goes through at least $n$ states and ends in an accept state.

![[Pasted image 20250813120256.png]]


This means that the sequence of states that accepts $s$ has length $n+1$.

> [!hint]
> With this, we don't mean that there are $n+1$ distinct states in the [[automata]], just that $s$ has to go through $n+1$ states, with that $+1$ being the start state. **States can be repeated**.


But we know that $n+1\geq p$, and $p$ is the number of distinct states in $M$, so $s$ is going through more states than the number of distinct states.

**SO AT LEAST ONE STATE IN THE ACCEPTING SEQUENCE MUST REPEAT**.

> [!hint]
> All the reasoning above is meant to include the $+1$, because if $n=p$, we don't have repeating states.


## FAQ

### What is the value of $p$?

1. In pumping‐lemma proofs you never need to worry about “finding” $p$. You assume _some_ DFA exists, call its number of states $p$, and proceed.

> [!hint]
> 1. Assume a DFA exists for $L$ (since it is regular by assumption).
> 2. Call the number of states $p$.
> 3. Keeping in mind the DFA and its number of states $p$, choose a string from the language that might break the pumping lemma.

2. The languages that we are trying to test are **infinite languages**, which are generated by [[Regular Expressions|regular expressions]] like $\{0^k1^k\}$. We need to construct a string by USING the variable $p$ in the regular expression, and then test it.

> [!example]
> For example in the language $\{0^k1^k\}$, we could test the string: $\{0^p1^p\}$.

3. You can't make the theorem vacuously true by having a high $p$: finite languages are always regular, and infinite languages must have strings that are longer than any $p$ by definition.

### What does this theorem accomplish?

1. The theorem is useful because if it doesn't hold, then the language isn't regular (it's necessary, but not sufficient).
2. It formalizes why regular languages cannot enforce unbounded matching (e.g.\ equal numbers of $a$'s and $b$'s) or deep counting constraints (automatons can't count).

### M recognizes the language. Isn't the language regular by definition?

1. The pumping lemma comes into play when **you don’t already have an automaton**—because you suspect none exists. Its role is to leverage a __hypothetical__ automaton to prove non-regularity.

### Why not use NFA's?

You can't guarantee a loop with NFA, because there is no guaranteed path. Especially considering we can have infinite **ε** paths.

![](Pasted%20image%2020241119125243.png)


## Formal Proof

Let $r_1, \dots, r_{n+1}$ be the sequence of states that $M$ enters while processing $s$.
So $r_{i+1}= δ(r_i,s_i)$ for $1 \leq i \leq n$.

The sequence, as explained before, has length $n+1$, which is at least $p+1$.

Among the first $p+1$ elements in the sequence, two must be the same state.

We call the first of these $r_j$ and the second $r_l$ 

![[Pasted image 20250814123659.png]]


## How to use (to prove L non-regular)

1. Assume $L$ is regular (we do this to obtain a contradiction).
2. Use the pumping lemma to guarantee the existence of $p$ (since $L$ is regular, $p$ exists).
3. Find a string in $L$ that has length $p$ or greater and that cannot be pumped (the most likely one).
4. Demonstrate that $s$ cannot be pumped by considering all the ways of dividing $s$ into $x$, $y$ and $z$ (within the 3 conditions).
5. The existence of $s$ contradicts the pumping lemma if $L$ were regular. Hence $L$ cannot be regular.

> [!hint] Finding the right $s$ to test
> You may need to hunt through several candidates for s before you discover one that works. Try members of $L$ that seem to exhibit the “essence” of $L$’s non-regularity.

> [!example]
> ![[Pasted image 20250814123725.png]]

> [!example]
> ![[Pasted image 20250814123741.png]]

> [!example]
> Consider the language B = {$0^n1^n$ | $n ≥ 0$}.
> We choose the string $0^n1^n$ with $n=2$, so **0011**.
> There can be 3 cases:
> 1. $y$ contains only **0**'s:
> In this case when we increment $i$ the number of **0**'s and **1**'s gets unbalanced, so condition 1 ($xy^iz$ for every $i$ is always in $A$) is not satisfied. 
> > [!hint]
> $x=0$, $y=0$, $z=11$. 
> > If we use $xy^2z$ it becomes **00011** and it is not in the language anymore
> 2. $y$ contains only **1**'s:
> same as before.
> 3. $y$ contains both **1**'s and **0**'s:
> Let $y$ = **01**, in this case the **0**'s and **1**'s would be out of order when we put $i>1$.
> > [!hint]
> It would come out as something like **001011**.
> 
> > [!attention]
> > Also condition 3 doesn't hold, because we can use p somehow.
> > We need to strategically choose the powers as something that scales with p/is bigger than p, so that the contradiction can work with any p.