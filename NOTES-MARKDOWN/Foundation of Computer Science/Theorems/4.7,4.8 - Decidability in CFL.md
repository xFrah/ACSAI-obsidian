Here, we describe [[12. Algorithms]] to determine whether a CFG generates a particular string and to determine whether the language of a CFG is empty.

## Membership in [[6. Context-Free Grammars|CFG]]

$$\large A_{CFG} = \{⟨G,w⟩\;| \;G\text{ is a CFG that generates string }w\}$$
For CFG G and string w, we want to determine whether G generates w.

> [!warning]
> One idea is to use G to go through all derivations to determine whether any is a derivation of w. 
> This idea doesn’t work, as **infinitely many derivations may have to be tried**. If G does not generate w, this algorithm would never halt. This idea gives a [[9. Turing Machines|Turing machine]] that is a recognizer, but not a decider, for $A_{CFG}$.


If G is in Chomsky Normal Form, any derivation of a string of length $n$ has precisely $2n-1$ steps.

So we just check all derivations with $2n-1$ steps, which exist in finite numbers.

We present a [[9. Turing Machines|TM]] $S$ that upon input $⟨G,w⟩$:
1. Convert $G$ to Chomsky Normal Form.
2. List all derivations of $G$ with $2n-1$ steps ($n=|w|$) (except if $n=0$, then list all derivations with 1 step).
3. If any of these derivations generate $w$, accept; reject otherwise.

> [!note]
> The problem of determining whether a CFG generates a particular string is related to the problem of compiling programming languages.

---

## Emptiness in [[6. Context-Free Grammars|CFG]]

We can show that the problem of determining whether a CFG generates any strings at all is decidable.

$$\large E_{CFG} = \{⟨G⟩\;|\; G \text{ is a CFG and } L(G) = ∅\}$$

> [!warning]
> We can't use the theorem above for Membership, to bruteforce all possible strings. This is due to the fact that we might have to try infinitely many strings and we may never halt.


In order to determine whether the language of a grammar is empty, we need to test **whether the start variable can generate a string of terminals**.

The algorithm does so by solving a more general problem:
It determines for each variable whether that **variable is capable of generating a string of terminals**.

### Can a variable generate a string of terminals?

We present a TM $R$, that upon on input $⟨G⟩$:
1. Marks all the terminal symbols in $G$. 
2. Scans all the rules of the grammar. 
3. If it finds a rule that permits some variable to be replaced by some string of symbols, all of which are already marked, the algorithm marks that variable too.
4. Keep doing this until it cannot mark any more variables.
5. If the start variable is not marked, accept; reject otherwise.