A language is Turing-recognizable **if and only if** some enumerator enumerates it.

> [!cite] Turing-recognizable (recursively enumerable / semi-decidable) definition
> There exists a TM that accepts all strings in the language; on strings not in the language, it may reject or loop forever (no guarantee of halting).

> [!cite] Enumeration meaning
> The enumerator enumerates a language if it prints **all and only** the strings in the language.

> [!hint]
> Based on the definitions above, we could rewrite the proof idea as:
> A language has a **Turing machine that recognizes it**, if and only if there **exists an enumerator that prints all** of its strings.


Since its "if and only if", we prove both directions of the theorem.

### If an enumerator exists for the language, we can construct a TM that recognizes it

Assume we have:
- A language $A$
- An [[9. Turing Machines#Enumerators|enumerator]] $E$ that enumerates $A$.
- A [[9. Turing Machines|TM]] M.

$M$ works in the following way:
1. Upon input $w$, run $E$. Every time that $E$ outputs a string, compare it with $w$.
2. If $w$ ever appears in the output of $E$, accept.

Clearly $M$ will accept every string in the language.

### If a TM recognizes a language, we can construct an enumerator for it

Say that $s_1,s_2,s_3,\dots$ is a list of all possible strings in $Σ^∗$.

> [!note] $\Sigma^*$ meaning
> Let $\Sigma=\{a,b\}$, then $\Sigma^*=\{a,b,aa,ab,ba,bb,aaa,\dots\}$


The enumerator is constructed as follows:
1. It ignores the input
2. Runs a counter $i=1,2,3,\dots$
3. Get the first $i$ strings in $Σ^∗$, run $M$ for $i$ times on each one of them.
4. If any branch ends in an accept state, print out the corresponding string.

> [!hint]
> It's **basically like a breadth first search**. 
> It is useful because if we went all-in on a single input string, there is no guarantee that it will ever halt.
> So this makes the never halt basically, by **computing strings in parallel**.

> [!hint] Inefficiency and infinite printing
> Of course, when we increment the counter, if in the previous iteration strings where accepted and printed, they will be printed again in the new iteration.
> But we don't give a shit about this.

> [!example]
> $$\Large\Sigma=\{a,b\}$$
> $$\Large\Sigma^* = \{a,\; b,\; aa,\; ab,\; ba,\; bb,\; aaa,\dots\}$$
> 
> Let $M$ be a TM that recognizes $A$.
> 
> ### $i = 1$
> - Simulate $M(a)$ for 1 step.
> - If $M$ accepts within 1 step, print `a`.
> 
> ### $i = 2$
> - Simulate $M(a)$ for 2 steps.
> - If $M$ accepts within 2 steps, print `a`.
> - Simulate $M(b)$ for 2 steps.
> - If $M$ accepts within 2 steps, print `b`.
> 
> ### $i = 3$
> - Simulate $M(a)$ for 3 steps.
> - If $M$ accepts within 3 steps, print `a`.
> - Simulate $M(b)$ for 3 steps.
> - If $M$ accepts within 3 steps, print `b`.
> - Simulate $M(aa)$ for 3 steps.
> - If $M$ accepts within 3 steps, print `aa`.
> 
