A language is Turing-recognizable **if and only if** some enumerator enumerates it.

> [!cite] Turing-recognizable (recursively enumerable / semi-decidable) definition
> There exists a TM that accepts all strings in the language; on strings not in the language, it may reject or loop forever (no guarantee of halting).

> [!cite] Enumeration meaning
> The enumerator enumerates a language if it prints **all and only** the strings in the language.

> [!hint]
> Based on the definitions above, we could rewrite the proof idea as:
> A language has a **Turing machine that recognizes it**, if and only if there **exists an enumerator that prints all** of its strings.


Since its "if and only if", we prove both directions of the theorem.

### If an enumerator exists for the language, we can construct a TM that recognizes it

Assume we have:
- A language $A$
- An [[Turing Machines#Enumerators|enumerator]] $E$ that enumerates $A$.
- A [[Turing Machines|TM]] M.

$M$ works in the following way:
1. Upon input $w$, run $E$.
2. If $w$ ever appears in the output of $E$, accept.

Clearly $M$ will accept every string in the language.

### If a TM recognizes a language, we can construct an enumerator for it

Say that $s_1,s_2,s_3,\dots$ is a list of all possible strings in $Σ∗$.
The enumerator is constructed as follows:
1. It ignores the input
2. Runs a counter $i=1,2,3,\dots$
3. For each input string $s_1,s_2,s_3,\dots$ in $Σ∗$, run the transition function of $M$ for $i$ times.
4. If any transition ends in an accept state, print out the corresponding string.

> [!hint]
> It's **basically like a breadth first search**. 
> It is useful because if we went all-in on a single input string, there is no guarantee that it will ever halt.
> So this makes the never halt basically, by **computing strings in parallel**.

