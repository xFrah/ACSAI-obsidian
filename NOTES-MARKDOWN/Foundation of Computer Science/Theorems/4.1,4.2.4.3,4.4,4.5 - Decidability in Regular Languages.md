Every question about [[3. Regular Languages]] is decidable, we have to prove it.

## Membership

We must determine whether a string is recognized by a specific finite automaton or not.
And we will prove that we can always do this, without ever halting.

### Membership in [[2. Finite Automata|DFA]]

We want to prove that language...

$$\large A_{DFA} = \{\underbracket{⟨B, w⟩}_{\text{input}} \;|\;B\text{ is a DFA that accepts string }w\}$$
...is decidable.
We want to prove that we can always tell whether a DFA will accept or reject a string, and will never halt.

In order to prove this we have a [[9. Turing Machines|TM]] $M$, that upon input $⟨B,w⟩$:
- Simulates the DFA B on it:
- Checks whether the final state is an accepting state or not (accepts or rejects accordingly).

> [!hint]
> The input $w$ is finite, we will only manage to use the transition function $|w|$ times, before landing on the final state.

> [!hint]
> This proof means that there exists a TM (or algorithm) that can always tell whether a string is accepted by a DFA or not (by simply simulating it).

---

### Membership  in [[2. Finite Automata|NFA]]

We want to prove that language...

$$\large A_{NFA} = \{\underbracket{⟨B, w⟩}_{\text{input}} \;|\;B\text{ is an NFA that accepts string }w\}$$
...is decidable.

We present a TM $N$ that upon input $⟨B,w⟩$:
- Converts the NFA $B$ to a DFA using the procedure from [[1.39 - DFA = NFA|this theorem]].
- Runs TM $M$ (from above proof) using the new converted DFA and string $w$ as input.
- Checks whether the final state is an accepting state or not (accepts or rejects accordingly).

---

### Membership in [[4. Regular Expressions]]

We want to prove that language...

$$\large A_{REX} = \{⟨R,w⟩\;|\; R \text{ is a regular expression that generates string }w\}$$

...is decidable.

We present a TM $P$ that upon input $⟨R,w⟩$:
- Converts $R$ into an equivalent NFA using [[1.55 - From reg. exp to finite automata|this method]].
- Runs TM $N$ (from the proof above) on the new converted NFA and input $w$.
- Check whether the final state is an accepting state or not (accepts or rejects accordingly).

---

## Emptiness

We must determine whether or not a finite automaton accepts any strings at all.
And we prove that we can always do this, without ever halting.

### Emptiness in DFA

$$\large E_{DFA} = \{⟨A⟩\;|\; A\text{ is a DFA and } L(A) = ∅\}$$

We present a TM $T$ that upon input $⟨A⟩$ (a DFA):
1. Marks the starting state.
2. Mark any state that has a transition coming into it from a state that is already marked.
3. Repeat step 2 until we can't mark any more states.
4. If no accept state is marked, reject; accept otherwise.

### Emptiness in general

Since we know that we can convert Regular expressions and NFA's to DFA's, we present just the DFA case.

---

## Equivalence

We need to determine whether two DFAs recognize the same language is decidable.
And we prove that we can always do this, without ever halting.

### Equivalence in DFA

$$\large EQ_{DFA} = \{⟨A,B⟩\;|\; A\text{ and }B\text{ are DFAs and }L(A) = L(B)\}$$

We construct a new DFA $C$ from A and B, where C accepts only those strings that are accepted by either A or B but not by both.

$$\large L(C) = \bigg(L(A)∩\overline{L(B)}\bigg) ∪ \bigg(L(A)∩\overline{L(B)}\bigg) .$$
![[Pasted image 20250824145454.png]]
(_This is called Symmetric Difference_)

Thus, if A and B recognize the same language, **C will accept nothing**.
For checking if the language of C is empty, we use the theorem for emptiness above.

We present a TM $F$, that on input $⟨A,B⟩$:
1. Constructs the DFA $C$ as described.
2. Runs TM $T$ (from the theorem above) on input $⟨C⟩$.
3. If $T$ accepts, accept; reject otherwise.